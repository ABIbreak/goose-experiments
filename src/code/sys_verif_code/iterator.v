(* autogenerated from sys_verif_code/iterator *)

From New.golang Require Import defn.
Definition iterator : go_string := "sys_verif_code/iterator".

Module iterator.

Section code.
Context `{ffi_syntax}.


Definition intIter : go_string := "sys_verif_code/iterator.intIter"%go.

(* go: intIter.go:14:6 *)
Definition intIterⁱᵐᵖˡ : val :=
  λ: "limit",
    exception_do (let: "limit" := (mem.alloc "limit") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       (let: "i" := (mem.alloc (type.zero_val #intT)) in
       let: "$r0" := #(W64 0) in
       do:  ("i" <-[#intT] "$r0");;;
       (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "limit")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
         (if: (~ (let: "$a0" := (![#intT] "i") in
         (![#funcT] "yield") "$a0"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition isAscii : go_string := "sys_verif_code/iterator.isAscii"%go.

(* go: intIter.go:24:6 *)
Definition isAsciiⁱᵐᵖˡ : val :=
  λ: "str",
    exception_do (let: "str" := (mem.alloc "str") in
    let: "ret_val" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ret_val" <-[#boolT] "$r0");;;
    do:  (let: "$a0" := (λ: "i",
      exception_do (let: "i" := (mem.alloc "i") in
      (if: ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "str") (![#intT] "i"))) ≥ #(W8 128)) || ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "str") (![#intT] "i"))) = #(W8 0))
      then
        let: "$r0" := #false in
        do:  ("ret_val" <-[#boolT] "$r0");;;
        return: (#false)
      else do:  #());;;
      let: "$r0" := #true in
      do:  ("ret_val" <-[#boolT] "$r0");;;
      return: (#true))
      ) in
    (let: "$a0" := (let: "$a0" := (![#sliceT] "str") in
    slice.len "$a0") in
    (func_call #intIter) "$a0") "$a0");;;
    return: (![#boolT] "ret_val")).

Definition main : go_string := "sys_verif_code/iterator.main"%go.

(* go: intIter.go:40:6 *)
Definition mainⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(intIter, intIterⁱᵐᵖˡ); (isAscii, isAsciiⁱᵐᵖˡ); (main, mainⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo iterator.iterator :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #iterator.iterator (λ: <>,
      exception_do (do:  (package.alloc iterator.iterator #()))
      ).

End code.
End iterator.
