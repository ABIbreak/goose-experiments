(* autogenerated from sys_verif_code/iterator *)

From New.golang Require Import defn.
Definition iterator : go_string := "sys_verif_code/iterator".

Module iterator.

Section code.
Context `{ffi_syntax}.


Definition intIter : go_string := "sys_verif_code/iterator.intIter"%go.

(* go: int_iter.go:5:6 *)
Definition intIterⁱᵐᵖˡ : val :=
  λ: "limit",
    exception_do (let: "limit" := (mem.alloc "limit") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       (let: "i" := (mem.alloc (type.zero_val #intT)) in
       let: "$r0" := #(W64 0) in
       do:  ("i" <-[#intT] "$r0");;;
       (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "limit")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
         (if: (~ (let: "$a0" := (![#intT] "i") in
         (![#funcT] "yield") "$a0"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition factorial : go_string := "sys_verif_code/iterator.factorial"%go.

(* go: int_iter.go:15:6 *)
Definition factorialⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "factorial" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 1) in
    do:  ("factorial" <-[#intT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "i",
      exception_do (let: "i" := (mem.alloc "i") in
      do:  ("factorial" <-[#intT] ((![#intT] "factorial") * ((![#intT] "i") + #(W64 1))));;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![#intT] "n") in
    (func_call #intIter) "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#intT] "factorial")).

Definition mapIter : go_string := "sys_verif_code/iterator.mapIter"%go.

(* go: map_iter.go:3:6 *)
Definition mapIterⁱᵐᵖˡ : val :=
  λ: "K" "V" "m",
    exception_do (let: "m" := (mem.alloc "m") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       let: "$range" := (![type.mapT "K" "V"] "m") in
       (let: "v" := (mem.alloc (type.zero_val "V")) in
       let: "k" := (mem.alloc (type.zero_val "K")) in
       map.for_range "$range" (λ: "$key" "$value",
         do:  ("v" <-["V"] "$value");;;
         do:  ("k" <-["K"] "$key");;;
         (if: (~ (let: "$a0" := (!["K"] "k") in
         let: "$a1" := (!["V"] "v") in
         (![#funcT] "yield") "$a0" "$a1"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition mapDeepEqual : go_string := "sys_verif_code/iterator.mapDeepEqual"%go.

(* go: map_iter.go:13:6 *)
Definition mapDeepEqualⁱᵐᵖˡ : val :=
  λ: "K" "V" "m1" "m2",
    exception_do (let: "m2" := (mem.alloc "m2") in
    let: "m1" := (mem.alloc "m1") in
    (if: (let: "$a0" := (![type.mapT "K" "V"] "m1") in
    map.len "$a0") ≠ (let: "$a0" := (![type.mapT "K" "V"] "m2") in
    map.len "$a0")
    then return: (#false)
    else do:  #());;;
    let: "ret_val" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ret_val" <-[#boolT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "k1" "v1",
      exception_do (let: "v1" := (mem.alloc "v1") in
      let: "k1" := (mem.alloc "k1") in
      let: "present" := (mem.alloc (type.zero_val #boolT)) in
      let: "v2" := (mem.alloc (type.zero_val "V")) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT "K" "V"] "m2") (!["K"] "k1")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v2" <-["V"] "$r0");;;
      do:  ("present" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "present")) || (~ (interface.eq (!["V"] "v1") (!["V"] "v2")))
      then
        let: "$r0" := #false in
        do:  ("ret_val" <-[#boolT] "$r0");;;
        return: (#false)
      else do:  #());;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![type.mapT "K" "V"] "m1") in
    ((func_call #mapIter) "K" "V") "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#boolT] "ret_val")).

Definition sliceIter : go_string := "sys_verif_code/iterator.sliceIter"%go.

(* go: slice_iter.go:3:6 *)
Definition sliceIterⁱᵐᵖˡ : val :=
  λ: "V" "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       let: "$range" := (![#sliceT] "s") in
       (let: "v" := (mem.alloc (type.zero_val "V")) in
       let: "j" := (mem.alloc (type.zero_val #intT)) in
       slice.for_range "V" "$range" (λ: "$key" "$value",
         do:  ("v" <-["V"] "$value");;;
         do:  ("j" <-[#intT] "$key");;;
         (if: (~ (let: "$a0" := (![#intT] "j") in
         let: "$a1" := (!["V"] "v") in
         (![#funcT] "yield") "$a0" "$a1"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition isAscii : go_string := "sys_verif_code/iterator.isAscii"%go.

(* go: slice_iter.go:15:6 *)
Definition isAsciiⁱᵐᵖˡ : val :=
  λ: "str",
    exception_do (let: "str" := (mem.alloc "str") in
    let: "ret_val" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ret_val" <-[#boolT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "i" "b",
      exception_do (let: "b" := (mem.alloc "b") in
      let: "i" := (mem.alloc "i") in
      let: "$r0" := (![#intT] "i") in
      do:  "$r0";;;
      (if: ((![#byteT] "b") ≥ #(W8 128)) || ((![#byteT] "b") = #(W8 0))
      then
        let: "$r0" := #false in
        do:  ("ret_val" <-[#boolT] "$r0");;;
        return: (#false)
      else do:  #());;;
      let: "$r0" := #true in
      do:  ("ret_val" <-[#boolT] "$r0");;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "str") in
    ((func_call #sliceIter) #byteT) "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#boolT] "ret_val")).

Definition reverseSlice : go_string := "sys_verif_code/iterator.reverseSlice"%go.

(* go: slice_iter.go:36:6 *)
Definition reverseSliceⁱᵐᵖˡ : val :=
  λ: "V" "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "rev_s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 "V" (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0")) in
    do:  ("rev_s" <-[#sliceT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "i" "v",
      exception_do (let: "v" := (mem.alloc "v") in
      let: "i" := (mem.alloc "i") in
      let: "$r0" := (!["V"] "v") in
      do:  ((slice.elem_ref "V" (![#sliceT] "rev_s") (((let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0") - #(W64 1)) - (![#intT] "i"))) <-["V"] "$r0");;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "s") in
    ((func_call #sliceIter) "V") "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#sliceT] "rev_s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(intIter, intIterⁱᵐᵖˡ); (factorial, factorialⁱᵐᵖˡ); (mapIter, mapIterⁱᵐᵖˡ); (mapDeepEqual, mapDeepEqualⁱᵐᵖˡ); (sliceIter, sliceIterⁱᵐᵖˡ); (isAscii, isAsciiⁱᵐᵖˡ); (reverseSlice, reverseSliceⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo iterator.iterator :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #iterator.iterator (λ: <>,
      exception_do (do:  (package.alloc iterator.iterator #()))
      ).

End code.
End iterator.
