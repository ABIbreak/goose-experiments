(* autogenerated from sys_verif_code/iterator *)

From New.golang Require Import defn.
Definition iterator : go_string := "sys_verif_code/iterator".

Module iterator.

Section code.
Context `{ffi_syntax}.


Definition intIter : go_string := "sys_verif_code/iterator.intIter"%go.

(* go: int_iter.go:5:6 *)
Definition intIterⁱᵐᵖˡ : val :=
  λ: "limit",
    exception_do (let: "limit" := (mem.alloc "limit") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       (let: "i" := (mem.alloc (type.zero_val #intT)) in
       let: "$r0" := #(W64 0) in
       do:  ("i" <-[#intT] "$r0");;;
       (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "limit")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
         (if: (~ (let: "$a0" := (![#intT] "i") in
         (![#funcT] "yield") "$a0"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition factorial : go_string := "sys_verif_code/iterator.factorial"%go.

(* go: int_iter.go:15:6 *)
Definition factorialⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "factorial" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 1) in
    do:  ("factorial" <-[#intT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "i",
      exception_do (let: "i" := (mem.alloc "i") in
      do:  ("factorial" <-[#intT] ((![#intT] "factorial") * ((![#intT] "i") + #(W64 1))));;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![#intT] "n") in
    (func_call #intIter) "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#intT] "factorial")).

Definition sliceIter : go_string := "sys_verif_code/iterator.sliceIter"%go.

(* go: slice_iter.go:3:6 *)
Definition sliceIterⁱᵐᵖˡ : val :=
  λ: "V" "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       let: "$range" := (![#sliceT] "s") in
       (let: "v" := (mem.alloc (type.zero_val "V")) in
       let: "i" := (mem.alloc (type.zero_val #intT)) in
       slice.for_range "V" "$range" (λ: "$key" "$value",
         do:  ("v" <-["V"] "$value");;;
         do:  ("i" <-[#intT] "$key");;;
         (if: (~ (let: "$a0" := (![#intT] "i") in
         let: "$a1" := (!["V"] "v") in
         (![#funcT] "yield") "$a0" "$a1"))
         then return: (#())
         else do:  #())));;;
       return: #())
       ))).

Definition isAscii : go_string := "sys_verif_code/iterator.isAscii"%go.

(* go: slice_iter.go:13:6 *)
Definition isAsciiⁱᵐᵖˡ : val :=
  λ: "str",
    exception_do (let: "str" := (mem.alloc "str") in
    let: "ret_val" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ret_val" <-[#boolT] "$r0");;;
    let: "loop_body" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: "i" "b",
      exception_do (let: "b" := (mem.alloc "b") in
      let: "i" := (mem.alloc "i") in
      let: "$r0" := (![#intT] "i") in
      do:  "$r0";;;
      (if: ((![#byteT] "b") ≥ #(W8 128)) || ((![#byteT] "b") = #(W8 0))
      then
        let: "$r0" := #false in
        do:  ("ret_val" <-[#boolT] "$r0");;;
        return: (#false)
      else do:  #());;;
      let: "$r0" := #true in
      do:  ("ret_val" <-[#boolT] "$r0");;;
      return: (#true))
      ) in
    do:  ("loop_body" <-[#funcT] "$r0");;;
    let: "iterator" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "str") in
    ((func_call #sliceIter) #byteT) "$a0") in
    do:  ("iterator" <-[#funcT] "$r0");;;
    do:  (let: "$a0" := (![#funcT] "loop_body") in
    (![#funcT] "iterator") "$a0");;;
    return: (![#boolT] "ret_val")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(intIter, intIterⁱᵐᵖˡ); (factorial, factorialⁱᵐᵖˡ); (sliceIter, sliceIterⁱᵐᵖˡ); (isAscii, isAsciiⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo iterator.iterator :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #iterator.iterator (λ: <>,
      exception_do (do:  (package.alloc iterator.iterator #()))
      ).

End code.
End iterator.
